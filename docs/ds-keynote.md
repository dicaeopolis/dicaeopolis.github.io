# 《数据结构》划重点笔记

## 什么是散列表？有哪些重要的解决冲突的方法？什么是装填因子？它对散列表的搜索效率有什么影响？如何计算在散列表上搜索成功或搜索失败时的平均搜索长度？（标红）

- 位置：教材 9.4

- 散列表即哈希表。用于将任意数据映射到连续内存空间里面，具体而言：利用哈希函数 \(h(k_i)\) 将数据 \(k_i\) 映射为内存单元的下标，由此构造的线性表结构即为散列表。

- 解决冲突的方法有多种：
  - 线性探测法：当出现哈希冲突时，一直往后找，直到找到空闲的内存空间。（遇到末尾则从头开始）优点：实现简单；缺点：数据容易堆积，也就是哈希值不同的两个数据要争夺同一个内存空间。
  - 平方探测法：只探测前面和后面的 \(i^2\) 的位置，可以解决堆积问题但是不一定可以探测到所有单元。
  - 其他开放定址法，如伪随机序列法，拉链法。
  - 拉链法：将具有相同哈希值的元素拉成一个链表，而原来的内存空间存放这个链表的头结点。

- 装填因子 \(\alpha\) ：指哈希表装入元素数与原来内存空间大小的比值。

- 装填因子太小，即哈希表空间未能充分利用；太大，则容易产生冲突。

- 计算平均搜索长度：【参考教材例 9.11】对于开放定址法而言：如果搜索成功，取每一个**关键字**，在构建的哈希表里面模拟一下探测过程，最后把比较次数取一下平均；如果搜索失败，取每一个**哈希值**，然后按照探测方法直到探测到空位置，记录探测次数取平均值即可。

**本知识点易考察综合题、填空题和选择题，考点为计算平均搜索长度。**

## 什么是线性表？它的最主要的性质是什么？
- 线性表是具有相同特性的数据元素的一个有限序列。

- 性质：序列性，存在开始和终端，并且每一个元素都有唯一的前驱和后继元素。

**本知识点易考察顺序表和链表进行插入、删除等操作的时间复杂度区别。也可能出判断题辨析线性表、顺序表和链表是上下位概念关系**

## 什么是逻辑结构？什么是数据元素？什么是数据项？什么是数据类型？它们有什么联系？

- 逻辑结构是指数据之间在逻辑上的组织方式，不涉及具体的物理存储细节。

- 数据元素是基本的数据单位，是能被识别和处理的最小数据组织单位。可以理解为一条“记录”或一个“实体”。

- 数据项是数据元素的不可再分的最小单位，是构成数据元素的具体属性。

- 数据类型是对数据项的值及其操作的集合的定义，指定了该数据的存储格式和可进行的操作。

- 例如：
```cpp
struct student
{
    std::string name;
    int age;
};
student group[4];
```
里面的数组可以理解为线性逻辑结构的**具体实现方式**，数组里面的每一个元素就是数据元素，这每一个元素里面的 `name` 和 `age` 项就是数据项，而 `student` 就是数据类型。

**本知识点易考判断题进行概念辨析，或者出送分题。**

## 什么是顺序存储结构？什么是链式存储结构？还有哪些其他存储结构？

- 顺序存储结构：数据存放在连续的内存空间里面，随机访问的时间复杂度为 \(O(1)\)，插入和删除的时间复杂度为 \(O(n)\)。
- 链式存储结构：数据存放在结点里面，每个结点不仅存放数据，还存放指针，用来存储该结点的单个前驱和/或后继，随机访问的时间复杂度为 \(O(n)\)，插入和删除的时间复杂度为 \(O(1)\)。
- 还有栈结构、队列结构、树结构、图结构和索引结构等。

## 什么是单链表？什么是双向链表？什么是循环链表？怎样在链表上进行插入和删除操作？

- 单链表：只有一个指向后继的指针域的链表。
- 双向链表： 指针域既指向后继又指向前驱的链表。
- 循环链表：头尾节点存在指针域关联形成循环的链表。
- 插入的方法：先取待插入结点，调整其指针域，然后调整原链表里面和该结点相连的结点的指针域。
- 删除的方法同理。

**易考点：哪一个选项的代码正确执行了插入/删除操作；或插入/删除操作共需要调整几个指针域。**

## 什么是栈？给定一个入栈序列，如何判断一个出栈序列是否可能？什么是链式栈？跟顺序栈相比，它有什么优缺点？

- 栈：**后进先出**的数据结构。
- 判定标准：对出栈序列进行模拟，判断有无非栈顶的元素提前出栈。
- 链栈即底层使用链表实现的栈。优点是无需担心栈容量问题，不会浪费空间；缺点是删除和插入元素的常数略大。

## 已知二叉树的前序序列和后序序列可以恢复一棵二叉树吗？需要满足什么条件才可以呢？如何由给定的条件恢复二叉树（包括所有可能的形状）？（标红）

- **不一定可以**。前序序列ULR，后序序列LRU，找到根节点之后，难以划分出左右子树。
- 何时可以？即可以划分出左右子树时，如果每个节点的左右子树大小都相等，那么我们只需要找子列的中点，就可以分开了，此时对应的是**满二叉树**。
- 如何恢复？遍历所有可能的左右子树分界点，递归检查左右子树是否合法。具体而言：从第一个结点到倒数第二个结点，遍历下标 \(i\) ，假定其是前序序列里面根节点左子树的最后一个结点，在后序序列里面找到它，就分出来左右子树，对这两个子树递归地进行这一操作，如果最终得到了合法的序列，成功恢复了一种可能的二叉树。

## 树与二叉树有哪些表示方法（如凹入表示、文氏图、广义表等）？树本身还有孩子-兄弟链表示法。如何在特定表示法下直接求取树或二叉树的某些特性（如树高等）？（标红）

- 表示方法：
  - 凹入表示：比如 Linux 里面 `tree` 命令的输出：
```
.
├── docs
│   ├── assets
│   │   ├── ds-t6.png
│   │   └── js
│   │       └── init-highlight.js
│   ├── benchmark-on-stl.md
│   ├── css
│   │   └── codehilite.css
│   ├── ds-keynote.md
│   ├── ds-t6.png
│   ├── ds-write-up.md
│   ├── index.md
│   ├── stl-wheels.md
│   ├── template-on-numeric-ring.md
│   └── test.md
├── mkdocs.yml
└── themes
    └── js
        ├── katex.js
        └── mathjax.js
```
  - 文氏图：利用圆圈的包含和并列表示树形层级。
  - 广义表：利用括号的嵌套表示层级。如 A(B(C,D),E)
  - 线连图：用线连接结点以直观表示树形结构。
  - 顺序表示：利用 \(2*i\) 和 \(2*i+ 1\) 来表示下标 \(i\) 结点的子节点，用于表示完全二叉树，例如堆。
  - 孩子-兄弟链表示：利用左孩子右兄弟方法将森林和二叉树互相转化。

## 什么是深度优先遍历DFS？什么是广度优先遍历BFS？针对特定的问题，如何选择使用DFS还是BFS？

- 深度优先遍历是一种用于遍历或搜索树或图的算法。它从根（或任意指定节点）开始，沿着一条路径 **尽可能深地** 探索每个分支，直到到达叶子节点或不能再深入为止。然后，它回溯（撤销）到前一个未完全探索的节点，并探索另一条路径。

- 工作原理（通常使用 **递归** 或**栈** 实现）：
  1. 访问起始节点。
  2. 将起始节点标记为已访问。
  3. 对于当前节点，选择一个未访问的邻居节点。
  4. 如果存在未访问的邻居节点，则对该邻居节点递归调用DFS。
  5. 如果没有未访问的邻居节点，则回溯到前一个节点。
  6. 重复此过程，直到所有可达节点都被访问。

- 特点：
  1. **栈（Stack）** 的数据结构特性：后进先出（LIFO）。
  2. **非最短路径算法**。
  3. **空间复杂度**：对于图来说，最坏情况下可能是 \(O(V+E)\)，其中 \(V\) 是顶点数，\(E\) 是边数；对于树来说，取决于树的深度。
  4. **时间复杂度**：\(O(V+E)\)。

 - 广度优先遍历也是一种用于遍历或搜索树或图的算法。它从根（或任意指定节点）开始，首先访问其所有直接邻居，然后访问这些邻居的所有未访问邻居，依此类推。它以 **“层”** 的方式向外扩展。

- 工作原理（通常使用 **队列** 实现）：
1. 访问起始节点。
2. 将起始节点标记为已访问，并将其添加到队列中。
3. 当队列不为空时，执行以下操作：
    * 从队列中取出（出队）一个节点。
    * 访问该节点的所有未访问的邻居节点。
    * 将这些未访问的邻居节点标记为已访问，并将它们添加到队列中。
4. 重复此过程，直到队列为空。

- 特点：
* **队列（Queue）** 的数据结构特性：先进先出（FIFO）。
* **最短路径算法**：在无权图中，BFS能够找到从起始节点到所有其他可达节点的最短路径（按边数计算）。
* **空间复杂度**：$O(V+E)$，最坏情况下需要存储所有节点和边。
* **时间复杂度**：$O(V+E)$。

- 如何选择使用DFS还是BFS？
  - 选择DFS的场景：
    1.  **查找所有可能的路径/解：** 当你需要遍历所有可能的路径或找到所有满足条件的解时，DFS非常适合。例如，回溯问题（如N皇后问题、组合总和）通常使用DFS。
    2.  **判断图中是否存在环：** DFS可以有效地检测图中的环。当你在DFS遍历过程中遇到一个已经访问过但仍在当前DFS路径上的节点时，就表示存在环。
    3.  **拓扑排序：** 对于有向无环图（DAG）的拓扑排序，DFS是一个常用的方法。
    4.  **连通分量：** 查找图中的连通分量或强连通分量。
    5.  **内存限制：** 在某些情况下，如果图非常宽但深度有限，DFS可能会比BFS占用更少的内存，因为它只需要存储当前路径上的节点。
    6.  **深度优先搜索的特性：** 如果你想要找到一个“深层”的解，或者对路径的深度更感兴趣，DFS是自然的选择。

- 选择BFS的场景：
  1.  **最短路径问题（无权图）：** 当你需要找到从一个节点到另一个节点的最短路径（以边数衡量）时，BFS是首选。例如，在一个迷宫中找到最短的逃生路径。
  2.  **层序遍历：** 如果你需要按层级顺序访问节点，例如在树中按层级打印节点。
  3.  **查找任意一个解，且解可能位于图的浅层：** 如果你知道某个问题的解可能在离起始节点不远的层级上，BFS可能会更快地找到它。

## 完全二叉树的结点个数、叶子结点数和高度之间满足怎样的关系？如何给完全二叉树的结点编号？

- 完全二叉树可以看作是最后一层所有节点集中在左侧，其他层构成满二叉树的一颗二叉树。

- **已知完全二叉树的结点个数，可以反推高度**：高度 \(h\) 的完全二叉树的结点个数介于 \(2^{h - 1}\) 和 \(2 ^{h} - 1\) 之间。反之不然。

- **已知完全二叉树的结点个数，可以反推其叶子结点数目**：已知结点数 \(n\)，首先反推其高度 \(h = \lfloor \log_2 n\rfloor + 1\)，然后可以算出从第一层到倒数第二层得到的满二叉树的节点数 \(n' = 2^{h - 1} - 1\)，于是得到底层节点数为 \(n_{\text{bottom}} = n - n'\)。这些节点都是叶子节点。然后考虑倒数第二层的结点，里面有些结点是底层结点的父节点，将倒数第二层的结点扣除这一部分，再加上底层节点即可得到叶子节点数：\(n_{\text{leaf}} = 2^{h - 1} - \lfloor\dfrac{n_{\text{bottom}} + 1}{2}\rfloor + n_{\text{bottom}}\)

- 编号问题，可以参考数组上建堆的方法，即对于下标 \(i\) 的结点，其子节点的下标为 \(2 \times i\) 和 \(2\times i + 1\)。

## 什么是二叉排序树？形成二叉排序树的充分必要条件是什么？如何构造一棵二叉排序树？（标红）

- BST 是满足结点偏序关系的二叉树。即一颗二叉树，它的所有结点都满足左儿子小于右儿子，那么就是一颗 BST。

- 构造方法：失败查找法，即首先对新的节点值进行查找，找到查找失败时的空指针，再直接在这个空指针位置插入数据。

- 如何计算给定 BST 的平均查找次数？对于成功而言，计算每一个结点到根节点路径长度的均值；对于失败而言，计算每一个空指针到根节点路径长度的均值。

- 这种插入方法有可能导致 BST 退化成链表，或者说左右子树高度严重不对称，因此引入了各种操作来调整树高，使其维持在 \(\log n\) 的数量级。

## 什么是B-树？怎样构造B-树？什么是B+树？B-树与B+树的差别在哪里？

### 什么是B-树？

- B-树是满足以下特点的树：
  * **多路分支**：每个节点可以有多个子节点（通常为m个，m称为B树的阶），而不仅仅是二叉树的两个子节点。这使得B树的高度远低于二叉树，从而减少了磁盘读写次数。
   * **平衡性**：所有的叶子节点都位于同一层，从根节点到任何叶子节点的路径长度都相同。这保证了查找、插入和删除操作的时间复杂度始终为$O(\log_m N)$，其中$N$是数据总量，$m$是阶数。
  * **节点结构**：一个B树节点通常包含$k-1$个关键字和$k$个子指针（其中$k \le m$）。这些关键字将节点内的键值空间划分为$k$个子区间，每个子指针指向对应子区间的数据或子树。
  * **关键字有序**：节点内的关键字是按升序排列的。

- 一个m阶B-树的属性通常定义为
  1.  每个节点最多有m个子节点。
  2.  每个非叶子节点（除根节点）最少有$\lceil m/2 \rceil$个子节点。
  3.  如果根节点不是叶子节点，那么它至少有两个子节点。
  4.  有$k$个子节点的非叶子节点拥有$k-1$个关键字。
  5.  所有的叶子节点都在同一层。

- B-树的插入操作
  1.  **查找插入位置**：首先，从根节点开始，根据要插入的关键字，找到它应该插入的叶子节点。
  2.  **插入关键字**：将关键字插入到该叶子节点中，并保持节点内关键字的有序性。
  3.  **处理节点上溢（分裂）**：如果插入后，当前节点的关键字数量超过了允许的最大值（m-1个），则发生上溢。
      * **分裂**：将该节点分裂为两个新节点。通常是将中间的关键字提升到父节点中，并将两侧的关键字分别放入两个新节点。
      * **向上递归**：如果父节点因为提升的关键字也发生上溢，则重复分裂操作，直到根节点或者找到一个没有上溢的节点。如果根节点上溢，则树的高度增加一层。

- B-树的删除操作：

  - 取决于删除后是否导致节点关键字数量低于最小值，即下溢。
  - 如果不出现下溢，则直接删除。
  - 如果出现下溢，通常通过**合并**或**借用**兄弟节点的关键字来解决。
    * **合并**：如果一个节点下溢，并且其兄弟节点也没有多余的关键字可以借用，那么它会与兄弟节点合并，并将父节点中分隔它们的关键字下移。
    * **借用**：如果一个节点下溢，但其兄弟节点有多余的关键字，则可以从兄弟节点借用一个关键字，并相应地调整父节点中的关键字。

- B+树：是B-树的一种变体，通常在数据库和文件系统中广泛使用。它在B-树的基础上进行了一些优化，使其更适合范围查询和磁盘I/O。

- B+树的主要特点是：
  * **所有关键字都出现在叶子节点**：非叶子节点只存储索引信息（关键字），不存储实际的数据记录。所有的实际数据记录都存储在叶子节点中。
  * **叶子节点形成有序链表**：所有的叶子节点包含全部关键字信息，并且它们之间通过指针连接成一个有序的链表。这使得范围查询非常高效，只需遍历叶子节点链表即可。
  * **非叶子节点只作为索引**：非叶子节点（内部节点）只存储关键字的拷贝，作为指向子节点的索引，不存储实际的数据指针。

- B-树与B+树的差别：
  1. 只需要记住相比于B-树，B+树是索引数据结构，并且叶子节点之间还有链表相连，即可。下面的对比都是围绕这个区别展开。
  1.  **数据存储方式**：
      * **B-树**：每个节点（包括非叶子节点和叶子节点）都可能存储关键字和指向数据记录的指针。这意味着数据可能分散在树的各个层级。
      * **B+树**：所有的数据记录都存储在叶子节点中。非叶子节点只存储关键字（索引）和指向子节点的指针，不存储实际数据。

  1.  **范围查询**：
      * **B-树**：进行范围查询时，可能需要多次从根节点开始遍历，效率相对较低。
      * **B+树**：由于叶子节点形成了一个有序链表，范围查询可以直接在叶子节点链表上进行遍历，效率非常高。这是B+树在数据库索引中被广泛应用的重要原因。

  1.  **适用场景**：
      * **B-树**：适用于内存中的数据结构，或者对随机查找性能要求较高，且对范围查询没有特别要求的场景。
      * **B+树**：更适合外部存储（如磁盘）中的数据结构，尤其在数据库和文件系统中作为索引结构。它优化了磁盘I/O和范围查询。

## 什么哈夫曼编码？哈夫曼编码是如何形成的？哈夫曼编码有哪些性质？（标红）

- Huffman 编码是基于哈夫曼树的编码方式，它既是一个前缀编码（即不会有一个编码是另外一个编码的前缀），也是信息密度最高的编码。下面讲哈夫曼树。

- 哈夫曼树是叶子节点具有最短带权路径长度 (WPL) 的树。构造方式为：首先将所有数据的频数从低到高排好，然后取出最前面的两个数据，将频数相加，得到这两个结点的根节点，然后把这个和放入有序数列中，维持数列低到高的有序性，

## 什么是图的邻接表、逆邻接表、十字链表、邻接表多重表？

## 什么是循环队列？rear和front指针通常代表什么？循环队列为满的条件与循环队列为空的条件之间有什么关系？改变其中一个条件能推导出另一个条件吗？

## 什么是分块查找？如何进行分块查找？如何计算分块查找的效率？

## 什么是AOV网？在AOV网上的经典问题和算法是什么？怎样进行拓扑排序？

## 什么是二路归并排序？算法复杂度是什么？有什么特点？

## 什么是图的单源最短路径问题？解决该问题的常见方法有哪些？

## 什么是快速排序？在不同条件下的算法复杂度是什么？

## 什么是AOE网络？结点和边分别代表什么？什么是关键活动？怎样求关键路径？

## 什么是多关键字排序？什么是基数排序算法？算法复杂度如何？

## 什么是KMP算法？什么是目标串？什么是模式串？next数组起到什么作用？

## 常用的排序算法有哪些？哪些排序算法是稳定的，哪些是不稳定的？这些排序算法的时间复杂度和空间复杂度如何？单趟排序能决定某个（些）元素的最终位置的排序算法有哪些？

## 什么是对半搜索算法？适用条件是什么？算法复杂度如何？什么是二叉判定树，怎样利用二叉判定树计算平均搜索长度？

## 什么是有向无环图DAG？它有怎样的特点？DAG有什么性质？DAG可以用来解决哪些问题？

## 什么是堆（heap）？堆有什么性质？如何构建堆？

