---
password: 8ceb3ed6ca52fb4382475e762e49b9e1
---
# 《数据结构》划重点笔记

## 什么是散列表？有哪些重要的解决冲突的方法？什么是装填因子？它对散列表的搜索效率有什么影响？如何计算在散列表上搜索成功或搜索失败时的平均搜索长度？（标红）

- 位置：教材 9.4

- 散列表即哈希表。用于将任意数据映射到连续内存空间里面，具体而言：利用哈希函数 \(h(k_i)\) 将数据 \(k_i\) 映射为内存单元的下标，由此构造的线性表结构即为散列表。

- 解决冲突的方法有多种：
  - 线性探测法：当出现哈希冲突时，一直往后找，直到找到空闲的内存空间。（遇到末尾则从头开始）优点：实现简单；缺点：数据容易堆积，也就是哈希值不同的两个数据要争夺同一个内存空间。
  - 平方探测法：只探测前面和后面的 \(i^2\) 的位置，可以解决堆积问题但是不一定可以探测到所有单元。
  - 其他开放定址法，如伪随机序列法，拉链法。
  - 拉链法：将具有相同哈希值的元素拉成一个链表，而原来的内存空间存放这个链表的头结点。

- 装填因子 \(\alpha\) ：指哈希表装入元素数与原来内存空间大小的比值。

- 装填因子太小，即哈希表空间未能充分利用；太大，则容易产生冲突。

- 计算平均搜索长度：【参考教材例 9.11】对于开放定址法而言：如果搜索成功，取每一个**关键字**，在构建的哈希表里面模拟一下探测过程，最后把比较次数取一下平均；如果搜索失败，取每一个**哈希值**，然后按照探测方法直到探测到空位置，记录探测次数取平均值即可。

**本知识点易考察综合题、填空题和选择题，考点为计算平均搜索长度。**

## 什么是线性表？它的最主要的性质是什么？
- 线性表是具有相同特性的数据元素的一个有限序列。

- 性质：序列性，存在开始和终端，并且每一个元素都有唯一的前驱和后继元素。

**本知识点易考察顺序表和链表进行插入、删除等操作的时间复杂度区别。也可能出判断题辨析线性表、顺序表和链表是上下位概念关系**

## 什么是逻辑结构？什么是数据元素？什么是数据项？什么是数据类型？它们有什么联系？

- 逻辑结构是指数据之间在逻辑上的组织方式，不涉及具体的物理存储细节。

- 数据元素是基本的数据单位，是能被识别和处理的最小数据组织单位。可以理解为一条“记录”或一个“实体”。

- 数据项是数据元素的不可再分的最小单位，是构成数据元素的具体属性。

- 数据类型是对数据项的值及其操作的集合的定义，指定了该数据的存储格式和可进行的操作。

- 例如：
```cpp
struct student
{
    std::string name;
    int age;
};
student group[4];
```
里面的数组可以理解为线性逻辑结构的**具体实现方式**，数组里面的每一个元素就是数据元素，这每一个元素里面的 `name` 和 `age` 项就是数据项，而 `student` 就是数据类型。

**本知识点易考判断题进行概念辨析，或者出送分题。**

## 什么是顺序存储结构？什么是链式存储结构？还有哪些其他存储结构？

- 顺序存储结构：数据存放在连续的内存空间里面，随机访问的时间复杂度为 \(O(1)\)，插入和删除的时间复杂度为 \(O(n)\)。
- 链式存储结构：数据存放在结点里面，每个结点不仅存放数据，还存放指针，用来存储该结点的单个前驱和/或后继，随机访问的时间复杂度为 \(O(n)\)，插入和删除的时间复杂度为 \(O(1)\)。
- 还有栈结构、队列结构、树结构、图结构和索引结构等。

## 什么是单链表？什么是双向链表？什么是循环链表？怎样在链表上进行插入和删除操作？

- 单链表：只有一个指向后继的指针域的链表。
- 双向链表： 指针域既指向后继又指向前驱的链表。
- 循环链表：头尾节点存在指针域关联形成循环的链表。
- 插入的方法：先取待插入结点，调整其指针域，然后调整原链表里面和该结点相连的结点的指针域。
- 删除的方法同理。

**易考点：哪一个选项的代码正确执行了插入/删除操作；或插入/删除操作共需要调整几个指针域。**

## 什么是栈？给定一个入栈序列，如何判断一个出栈序列是否可能？什么是链式栈？跟顺序栈相比，它有什么优缺点？

- 栈：**后进先出**的数据结构。
- 判定标准：对出栈序列进行模拟，判断有无非栈顶的元素提前出栈。
- 链栈即底层使用链表实现的栈。优点是无需担心栈容量问题，不会浪费空间；缺点是删除和插入元素的常数略大。

## 已知二叉树的前序序列和后序序列可以恢复一棵二叉树吗？需要满足什么条件才可以呢？如何由给定的条件恢复二叉树（包括所有可能的形状）？（标红）

- **不一定可以**。前序序列ULR，后序序列LRU，找到根节点之后，难以划分出左右子树。
- 何时可以？即可以划分出左右子树时，如果每个节点的左右子树大小都相等，那么我们只需要找子列的中点，就可以分开了，此时对应的是**满二叉树**。
- 如何恢复？遍历所有可能的左右子树分界点，递归检查左右子树是否合法。具体而言：从第一个结点到倒数第二个结点，遍历下标 \(i\) ，假定其是前序序列里面根节点左子树的最后一个结点，在后序序列里面找到它，就分出来左右子树，对这两个子树递归地进行这一操作，如果最终得到了合法的序列，成功恢复了一种可能的二叉树。

## 树与二叉树有哪些表示方法（如凹入表示、文氏图、广义表等）？树本身还有孩子-兄弟链表示法。如何在特定表示法下直接求取树或二叉树的某些特性（如树高等）？（标红）
