# 《计算机组成原理》理论课程作业与笔记归档

供存档和复习用。

## 第一次作业

李琰，2024302183007

![alt text](image.png)

![alt text](0848B7512D832B0543A0C429A8B7E2E9.jpg)

![alt text](image-1.png)

![alt text](image-2.png)

![alt text](image-3.png)

![alt text](image-4.png)

![alt text](F2909820A097989E75B1DE0CBEE3575D.jpg)

## 第二次作业

![alt text](image-29.png)

这个题并不需要我们进行具体的运算。只需要按规则译码即可。

(1) 无符号整数，直接原码译码： $R_1: 108B_{16}=4235_{10}$，$R_2: 8080108B_{16}=2155876491_{10}$

(2) 有符号整数，按补码译码： $R_1: 108B_{16}=4235_{10}$，$R_2$ 直接模运算： $2155876491-4294967296=-2139090805$

(3) FP32: S1E8M23, FP64: S1E11M52，首先写成二进制并且把符号位，阶码，尾数断开：

```text
R1: 0000 0000 0000 0000 0001 0000 1000 1011
  = 0 00000000 00000000001000010001011 是一个非规格化浮点数。
  = (-1)^0 * 2^(0-126) * 0.00000000001000010001011

R2: 1000 0000 1000 0000 0001 0000 1000 1011
  = 1 00000001 00000000001000010001011
  = (-1)^1 * 2^(1-127) * 1.00000000001000010001011
```

得到：

$$
R_1 = 0.00000000001000010001011_2 \times 2^{-126}\\
R_2 = -1.00000000001000010001011_2 \times 2^{-126}
$$

![alt text](image-30.png)

为简便，使用十六进制表记。

| 关系表达式                | 运算类型   | 结果 | 说明                                   |
|:------------------------:|:---------:|:----:|:--------------------------------------:|
| 0==0U                     | 无符号整数 |  1   | 0000 0000H = 0000 0000H |
| -1 < 0                    | 带符号整数 | 1 | FFFF FFFFH(-1) < 0000 0000H(0) |
| -1 < 0U                   | 无符号整数 |  0   | 11…1B（2³²-1）>00…0B（0）|
| 2147483647 > -2147483647 - 1 | 带符号整数 |  1   | 011…1B（2³¹-1）>100…0B（-2³¹）|
| 2147483647U > -2147483647 - 1 |无符号整数 |  0   | 7FFF FFFFH(2³¹-1) < 8000 0000H (2³¹) |
| 2147483647 > (int)2147483648U | 带符号整数 |  1   | 7FFF FFFFH > 8000 0000H (-2³¹) |
| -1 > -2                   | 带符号整数 |  1   | FFFF FFFF(-1) > FFFF FFFE(-2) |
| (unsigned)-1 > -2         | 无符号整数 | 1 | FFFF FFFF(2³²-1) > FFFF FFFE(2³²-2) |

![alt text](image-31.png)

```text
(1)
x = -FFFAH = -65530

(2)
y = -2004H = -8196

(3)
z = 4294967296 - 6 = 4294967290

(4)
c = 2*16+10 = 42 = '*'

(5)
a = 1100 0100 0100 1000 0000 0000 0000 0000
  = -1 * (10001000) * 1.10010000000000000000000
  = -1 * 2^9 * (1 + 2^-1 + 2^-4)
  = -1 * (512 + 256 + 32)
  = -800

(6)
b = 1100 0000 0010 0100 1000 0000 .... 0000
  = -1 * (100 0000 0010) * 1.01001
  = -1 * 2^3 * (1 + 2^-2 + 2^-5)
  = -1 * (8 + 2 + 0.25)
  = -10.25
```

![alt text](image-32.png)

我们首先得到数据的字节型表示：

```text
x = -0.125 = -1 * 2^(-3) * 1.0 = -1 * 2^(124-127) * 1.0
  = 1 0111 1100 0000 .... 0000
  = 1011 1110 0000 0000 .... 0000
  = BF 00 00 00
y = 7.5 = 1 * 2^(2) * 1.111
  = 0 1000 0001 1110 0000 .... 0000
  = 0100 0000 1111 0000 0000 .... 0000
  = 40 F0 00 00
i = 100 = 64 + 32 + 4 = 0000 0000 0110 0100 = 00 64
```

在小端序机器上面：

```text
  00 00 00 BF ** ** ** ** 00 00 F0 40 64 00
 |     x     |           |     y     |  i  |
 100         104         108         112   
```

在大端序机器上面：

```text
  BF 00 00 00 ** ** ** ** 40 F0 00 00 00 64
 |     x     |           |     y     |  i  |
 100         104         108         112  
```

## 第三次作业

![alt text](image-34.png)

| w        |          | func1(w) |          | func2(w) |          |
|----------|----------|----------|----------|----------|----------|
| 机器数   | 值       | 机器数   | 值       | 机器数   | 值       |
| 0000 007F | 127      | 0000 007F | 127 | 0000 007F | 127 |
| 0000 0080 | 128      | 0000 0080 | 128 | FFFF FF80 | -128 |
| 0000 00FF | 255      | 0000 00FF | 255 | FFFF FFFF | -1 |
| 0000 0100 | 256      | 0000 0000 | 0 | 0000 0000 | 0 |

关键点是逻辑移位不补零，算术移位补零，以及整数移位的截断。

![alt text](image-36.png)

![alt text](image-35.png)

| 表示   | X    | x  | Y    |  y    | X+Y | x+y  | OF | SF | CF | X-Y | x-y | OF | SF | CF |
|-------|------|-----|------|------|------|------|----|----|----|-----|-----|----|----|----|
| 无符号 | 0xB0 | 176 | 0x8C | 140  | 0x3C | 316  | 1 | 0  | 1  | 0x24 | 36 | 0  | 0  |  0 |
| 带符号 | 0xB0 | -80 | 0x8C | -116 | 0x3C | -196 | 1 | 0  | 1  | 0x24 | 36 | 0  | 0  |  0 |

从硬件角度理解，$OF = C_{out} \oplus C_{n-1}$, $SF = F_{n}$, $CF = C_{out} \oplus Sub$。

加法时，$C_{out}=1,C_{n-1}=0,F_{n}=0,Sub=0$，根据上述计算规则可得各标志位值。

减法时，$C_{out}=1,C_{n-1}=1,F_{n}=0,Sub=1$，根据上述计算规则可得各标志位值。

从意义上理解，加法时结果为正数，出现溢出且最高位产生进位；减法时结果也为正数，未出现溢出或产生最高位的进位。

![alt text](image-37.png)

```text
(1)
补码：
 x=001010
 y=111010
-y=000110
x+y = 000100 = 4
x-y = 010000 = 16

(2)
原码：符号位 1
x=001010
y=000110

       001010
    x  000110
---------------
      001010
     001010
---------------
  00000111100
x*y = 111100 = 28

(3)
 y=111010
-y=000110

Q      A      Q_{0}Q_{-1}
000000 001010 00
000000 000101
000110 000101 10
000011 000010
111101 000010 01
111110 100001
000100 100001 10
000010 010000
111100 010000 01
111110 001000
111111 000100 00

x*y = -60

(4)
原码：符号位 1
 x=001010
 y=000110
-y=111010
S R      Q
0 000000 001010
0 000000 01010_
1 000110 01010_
1 000110 010100
1 001100 10100_
1 000110 10100_
1 000110 101000
1 001011 01000_
1 000101 01000_
1 000101 010000
1 001010 10000_
1 000100 10000_
1 000100 100000
1 000111 00000_
1 000001 00000_
1 000001 000000
1 000010 00000_
0 000100 00000_
0 000100 000001
R = 4, Q = -1
```

![alt text](image-38.png)

55 = 56 - 1, 56 = 7 * 8 = (8 - 1) * 8，由此可以构造：

```c
55 * x == (((x << 3) - 1) << 3) - x
```

仅需 3 + 1 + 3 + 1 = 8 个 clk.

![alt text](image-39.png)

(1) 永真。int 转 double 不会出现 INF 或者 NaN，因此无论如何都是大于零的。

(2) float 在 x 接近 INT_MAX 的时候，粒度会变稀到小于 1。因此当 x = 2146483647 时为假。

(3) 显然 x+y 溢出时两者不等。取 x = 2146483647, y = 1 即可。

(4) 永真。这里没有大数吃小数的问题，因为 double 在 int 的粒度足够。

(5) 永真，理由同上。

(6) 取 x = 0, y = 1，这样 dx/dx = -nan。

![alt text](image-40.png)

![alt text](image-41.png)
