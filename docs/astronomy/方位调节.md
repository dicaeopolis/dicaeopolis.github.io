<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>极轴校准助手 Pro</title>
    <style>
        :root {
            --primary-color: #00ff00; /* 改为高亮绿，更显眼 */
            --warning-color: #ffcc00;
            --bg-color: #000000;
            --panel-bg: rgba(20, 20, 20, 0.85);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: #ffffff;
            font-family: 'SF Mono', 'Roboto Mono', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        /* --- 视觉核心：中央标尺线 --- */
        .crosshair-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5; /* 提高层级 */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .center-line {
            position: absolute;
            width: 4px; /* 加粗 */
            height: 70%; /* 占据屏幕70%高度 */
            background-color: var(--primary-color);
            box-shadow: 0 0 15px var(--primary-color); /* 增加发光效果 */
            border-radius: 2px;
        }

        /* 顶部箭头 */
        .center-line::after {
            content: '';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 15px solid var(--primary-color);
        }

        /* 底部指示文字 */
        .direction-label {
            position: absolute;
            top: 15%; /* 放在线上方一点 */
            left: 50%;
            transform: translateX(-50%);
            color: var(--primary-color);
            font-size: 14px;
            font-weight: bold;
            background: rgba(0,0,0,0.5);
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 6;
        }

        /* --- 数据面板 --- */
        .info-panel {
            position: relative;
            z-index: 10;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            background: var(--panel-bg);
            border-bottom: 1px solid #333;
        }

        .data-column {
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 12px;
        }

        .val { color: var(--primary-color); font-weight: bold; }
        .lbl { color: #888; margin-right: 5px; }

        /* --- 底部主显示区 --- */
        .main-display {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding-bottom: 40px;
            padding-top: 20px;
            background: linear-gradient(to top, var(--bg-color) 20%, transparent);
            text-align: center;
            z-index: 10;
        }

        .azimuth-value {
            font-size: 56px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            font-variant-numeric: tabular-nums; /* 数字等宽，防止抖动 */
        }

        .sub-text {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 10px;
        }

        .deviation-box {
            display: inline-block;
            background: #222;
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid #444;
            font-size: 16px;
            color: var(--warning-color);
            min-width: 200px;
        }

        /* --- 启动遮罩 --- */
        #start-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        button.start-btn {
            background: var(--primary-color);
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 20px var(--primary-color);
            margin-bottom: 20px;
        }

        .tips { color: #888; font-size: 12px; max-width: 80%; line-height: 1.6; }

    </style>
</head>
<body>

    <!-- 标尺系统 -->
    <div class="crosshair-container">
        <div class="direction-label">↑ 手机顶部 (指向极轴)</div>
        <div class="center-line"></div>
    </div>

    <!-- 顶部信息 -->
    <div class="info-panel">
        <div class="data-column">
            <div><span class="lbl">GPS:</span><span id="txt-gps" class="val">获取中...</span></div>
            <div><span class="lbl">Alt:</span><span id="txt-alt" class="val">--</span> km</div>
        </div>
        <div class="data-column" style="text-align: right;">
            <div><span class="lbl">磁偏角:</span><span id="txt-dec" class="val">--</span>°</div>
            <div><span class="lbl">精度:</span><span id="txt-acc" class="val">--</span></div>
        </div>
    </div>

    <!-- 底部主数显 -->
    <div class="main-display">
        <div class="sub-text">真北方位角 (True Azimuth)</div>
        <div class="azimuth-value" id="val-azimuth">---.--°</div>
        <br>
        <div class="deviation-box" id="val-deviation">请点击开始校准</div>
    </div>

    <!-- 启动遮罩 -->
    <div id="start-overlay">
        <button class="start-btn" id="btn-start">开始校准</button>
        <div class="tips">
            1. 请做“8”字形挥动手机以校准罗盘<br>
            2. 允许获取位置和方向权限<br>
            3. 保持手机竖屏使用
        </div>
        <div id="status-log" style="margin-top:20px; color:#ff5555; font-size:12px;"></div>
    </div>

    <script>
        // 核心数据状态
        const appState = {
            declination: 0,
            hasDeclination: false,
            lat: 0,
            lon: 0,
            alt: 0
        };

        const ui = {
            gps: document.getElementById('txt-gps'),
            alt: document.getElementById('txt-alt'),
            dec: document.getElementById('txt-dec'),
            acc: document.getElementById('txt-acc'),
            azimuth: document.getElementById('val-azimuth'),
            deviation: document.getElementById('val-deviation'),
            overlay: document.getElementById('start-overlay'),
            log: document.getElementById('status-log')
        };

        // 辅助数学函数
        const toRad = deg => deg * Math.PI / 180;
        const toDeg = rad => rad * 180 / Math.PI;

        // 1. 初始化
        document.getElementById('btn-start').addEventListener('click', async () => {
            // 请求全屏体验
            try {
                if (document.documentElement.requestFullscreen) {
                    await document.documentElement.requestFullscreen();
                }
            } catch(e) {}

            ui.log.innerText = "正在请求权限...";
            
            // 请求IOS/某些安卓的传感器权限
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission !== 'granted') {
                        ui.log.innerText = "传感器权限被拒绝";
                        return;
                    }
                } catch (error) {
                    console.error(error);
                }
            }

            // 获取GPS
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(successGPS, errorGPS, {
                    enableHighAccuracy: true,
                    timeout: 10000
                });
            } else {
                ui.log.innerText = "该浏览器不支持 GPS";
            }
        });

        // 2. GPS 回调
        function successGPS(pos) {
            const crd = pos.coords;
            appState.lat = crd.latitude;
            appState.lon = crd.longitude;
            appState.alt = (crd.altitude || 0) / 1000; // m -> km

            ui.gps.innerText = `${appState.lat.toFixed(2)}, ${appState.lon.toFixed(2)}`;
            ui.alt.innerText = appState.alt.toFixed(2);
            ui.acc.innerText = `±${crd.accuracy.toFixed(0)}m`;
            
            ui.log.innerText = "GPS成功，获取磁偏角...";
            fetchDeclination();
        }

        function errorGPS(err) {
            ui.log.innerText = `GPS错误: ${err.message}`;
            // 即使GPS失败，也尝试启动罗盘（假设磁偏角0）
            setTimeout(startCompass, 2000);
        }

        // 3. 获取磁偏角
        async function fetchDeclination() {
            const date = new Date().toISOString().split('T')[0];
            const url = `https://geomag.bgs.ac.uk/web_service/GMModels/wmm/2025?latitude=${appState.lat}&longitude=${appState.lon}&altitude=${appState.alt}&date=${date}&format=json`;
            
            try {
                const res = await fetch(url);
                const json = await res.json();
                appState.declination = json["geomagnetic-field-model-result"]["field-value"]["declination"]["value"];
                appState.hasDeclination = true;
                ui.dec.innerText = appState.declination.toFixed(2);
                ui.overlay.style.display = 'none'; // 隐藏遮罩
                startCompass();
            } catch (e) {
                ui.log.innerText = "磁偏角API请求失败，使用默认值 0°";
                setTimeout(() => {
                    ui.overlay.style.display = 'none';
                    startCompass();
                }, 1500);
            }
        }

        // 4. 启动罗盘监听
        function startCompass() {
            // 优先使用 absolute，Android 必备
            if ('ondeviceorientationabsolute' in window) {
                window.addEventListener('deviceorientationabsolute', handleOrientation);
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
            }
        }

        // 5. 核心姿态解算算法 (修复版)
        function handleOrientation(e) {
            let alpha = e.alpha; // Z轴 0-360
            let beta = e.beta;   // X轴 -180~180 (俯仰)
            let gamma = e.gamma; // Y轴 -90~90 (横滚)

            if (alpha === null) return;

            // 转换为弧度
            const _a = toRad(alpha);
            const _b = toRad(beta);
            const _g = toRad(gamma);

            // --- 投影算法修正 ---
            // 目标：计算手机顶部向量 (0, 1, 0) 在地球水平坐标系下的投影角度
            // 手机坐标系: Y轴向上(顶部), X轴向右, Z轴垂直屏幕
            // 地球坐标系(相对): 我们需要计算 Y轴在水平面上的投影分量

            // 旋转矩阵分量计算 (Z-X-Y 顺序, 从地球系到手机系)
            // 我们需要 R_inv * [0, 1, 0]^T 的前两个分量 (x, y)
            
            // 公式推导 (简化后):
            // Vy (North component) = cos(alpha)*cos(gamma) - sin(alpha)*sin(beta)*sin(gamma) 
            // Vx (East component)  = sin(alpha)*cos(gamma) + cos(alpha)*sin(beta)*sin(gamma)
            
            // 注意：W3C标准中，Alpha是逆时针增加的。
            // 但 atan2(x, y) 通常计算的是逆时针角度。
            // 罗盘方位角是顺时针的 (N=0, E=90)。
            
            // 我们使用更通用的“倾斜补偿罗盘”公式：
            // 1. 计算手机Y轴在水平面的投影
            // fix: 很多网上的公式其实是算 Z轴(屏幕朝向)的方位角，我们要的是 Y轴(手机顶部)
            
            const cA = Math.cos(_a); const sA = Math.sin(_a);
            const cB = Math.cos(_b); const sB = Math.sin(_b);
            const cG = Math.cos(_g); const sG = Math.sin(_g);

            // 手机坐标系向量 V_phone = (0, 1, 0)
            // 转换到地球坐标系 V_earth = R^T * V_phone
            // R^T 的第二列就是我们需要的
            
            // Rx^T = [1, 0, 0; 0, cB, -sB; 0, sB, cB]
            // Ry^T = [cG, 0, sG; 0, 1, 0; -sG, 0, cG]
            // Rz^T = [cA, -sA, 0; sA, cA, 0; 0, 0, 1]
            // V_earth = Rz^T * Rx^T * Ry^T * [0,1,0]^T
            // 这里的顺序极其重要，Android Chrome 通常遵循 Z-X-Y 顺序
            
            // 经过推导，手机 Y轴(0,1,0) 在地球坐标系下的水平分量 (x, y):
            // x (East)  = - cA * sG - sA * sB * cG
            // y (North) = - sA * sG + cA * sB * cG
            
            // *修正*：上述公式推导经常因为符号定义出错。
            // 让我们使用极轴校准的实测修正逻辑：
            // 当手机平放 (beta=0, gamma=0), x = -sin(alpha)*0... 好像不对。
            
            // 重新采用最稳健的计算方式：
            // Heading = 360 - alpha (平放时)
            // 引入倾斜项:
            
            const numer = sA * cB + cA * sB * sG; // 对应 East 分量
            const denom = cA * cB - sA * sB * sG; // 对应 North 分量
            
            // 计算数学角度 (逆时针)
            // 注意：这里我们故意交换了通常的 x,y 位置来匹配 atan2(y, x) -> atan2(East, North)
            // 这样 0度 是北，90度是东
            
            let heading = Math.atan2(numer, denom); // result in radians
            
            // 转换为角度
            heading = toDeg(heading);
            
            // 此时 heading 是相对于 "North" 的角度
            // 如果 alpha 增加 (手机左转)，heading 应该减小。
            // 上面的公式：若 alpha 增加，cos(alpha) 减小...
            // 实测中，通常需要取反或者用 360 减去结果来符合顺时针罗盘习惯
            
            // 针对 Android deviceorientationabsolute 的特定修正：
            // Android 的 alpha 是 0=North, 90=West (逆时针!)
            // 我们需要的 Azimuth 是 0=North, 90=East (顺时针)
            
            // 最终极轴修正逻辑：
            // x_h = sin(alpha) * cos(beta)
            // y_h = cos(alpha) * cos(gamma) + sin(alpha) * sin(beta) * sin(gamma)
            // 这里的 y_h, x_h 是投影分量
            
            const x_h = sA * cB - cA * sB * sG;
            const y_h = cA * cB + sA * sB * sG; 
            
            // 修正后的计算：
            // 360 - deg
            let azimuth = toDeg(Math.atan2(x_h, y_h));
            
            // 调整为 0-360
            if (azimuth < 0) azimuth += 360;
            
            // 此时 azimuth 应该是顺时针增加的磁北角度
            // 必须反转方向因为 alpha 是逆时针定义的
            azimuth = 360 - azimuth;
            if (azimuth >= 360) azimuth -= 360;

            // 6. 加入磁偏角 (真北计算)
            // 真北 = 磁北 + 磁偏角
            // 如果磁偏角是 -7 (西偏), 真北 = 磁北 - 7
            let trueAzimuth = azimuth + appState.declination;
            
            // 再次归一化
            if (trueAzimuth < 0) trueAzimuth += 360;
            if (trueAzimuth >= 360) trueAzimuth -= 360;

            updateDisplay(trueAzimuth);
        }

        function updateDisplay(azimuth) {
            ui.azimuth.innerText = azimuth.toFixed(2) + "°";

            // 计算偏差
            // 目标是 0 度 (也就是 360)
            let diff = azimuth;
            // 将 0-360 映射到 -180 ~ +180
            // 例如：359度 -> -1度 (偏左)
            // 1度 -> +1度 (偏右)
            
            if (diff > 180) diff -= 360;
            
            // 显示逻辑
            const absDiff = Math.abs(diff);
            const el = ui.deviation;
            
            if (absDiff < 0.5) {
                el.innerText = "★ 已对准真北 ★";
                el.style.color = "#00ff00";
                el.style.borderColor = "#00ff00";
            } else {
                el.style.color = "#ffcc00";
                el.style.borderColor = "#ffcc00";
                
                // 极轴校准指导：
                // 如果显示 +10度 (指向了真北右边/东边)，需要向西(左)调
                // 如果显示 -10度 (指向了真北左边/西边)，需要向东(右)调
                if (diff > 0) {
                    el.innerText = `向左(西) 调 ${absDiff.toFixed(2)}°`;
                } else {
                    el.innerText = `向右(东) 调 ${absDiff.toFixed(2)}°`;
                }
            }
        }
    </script>
</body>
</html>