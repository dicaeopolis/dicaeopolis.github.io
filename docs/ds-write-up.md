# 《数据结构》期末复习题题解

## 第五版第一套题目
### 单项选择题

1.**数据结构是指**______。  
   A. 一种数据类型  
   B. 数据的存储结构  
   C. 一组性质相同的数据元素的集合  
   D. 相互之间存在一种或多种特定关系的数据元素的集合  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：D。</b> 三短一长选最长好吧。其实数据结构的精妙之处就是利用好数据之间的相互关系来组织数据，以获得更佳的性能。ABC选项描述都没有抓住“数据间相互关系”这个关键词。

<p></p>

</details>

2.**以下算法的时间复杂度为**______。  
   ```c
   void fun(int n)
   {  int i = 1, s = 0;
      while (i <= n)
      {  s += i + 100; i++;  }
   }
   ```  
   A. $O(n)$  
   B. $O(\sqrt{n})$  
   C. $O(n\log_2 n)$  
   D. $O(\log_2 n)$  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：A。</b> 本题 s 是一个障眼法，决定循环次数的只有 i 和 n。根据代码，i 从 1 开始，每一次循环 i 都增加 1，直到 i 的值增加到 n 为止。因此一共执行了 n 次循环，选A。

<p></p>

<b>变体：如果把循环条件改成 `s <= n`，则应该选哪个选项呢？</b>

<details>
<summary>点击查看解答</summary>
<p></p>

考虑循环执行了 x 次，则
$$
s=\sum_{i=1}^{x}100+i = 100x+\dfrac{x(x-1)}{2}
$$
也就是 s 增长率在 x^2 量级，由于循环条件为 s<=n，就可以得出 x=O(√n)。
<p></p>
当然也可以利用上式把 x 关于 n 的精确表达式解出来再做分析，原理是一样的。
<p></p>
原书给的答案是B，其实想考的是这个，但是出题人有点草台班子，弄巧成拙了。

<p></p>
</details>

<p></p>

</details>

3.**在一个长度为$n$的有序顺序表中删除第一个元素值为$x$的元素时，在查找元素$x$时采用二分查找方法，此时删除算法的时间复杂度为**______。  
   A. $O(n)$  
   B. $O(n\log_2 n)$  
   C. $O(n^2)$  
   D. $O(\sqrt{n})$  


<details>

<summary> 答案 </summary>

<p></p>

<b>答案：A。</b> 这里删除算法分两步：第一步找到待删除的第一个元素，这一步由于原来的表是有序的，所以可以使用二分法，每次排除一半的区间，时间复杂度为 O(log_2 n)，第二步是把这个元素删除，由于采用线性表存储所以时间复杂度是 O(n)。两步加起来，由于第一步相比第二步用时太短，几乎可以忽略不计，所以总的时间复杂度为 O(n)。

<details>
<summary>为什么线性表随机删除单个元素的时间复杂度是 O(n) ?</summary>
<p></p>

随机删除元素，则任一下标 i (为方便书写，从 1 开始)的元素被选中的概率都是 1/n，删除操作需要把后面的 (n-i) 个元素都往前移动一位，因此移动次数的期望值为：

$$
E=\sum_1^{n}\dfrac {n-i}{n}= \dfrac{n-1}2
$$

是 O(n) 级别的操作。
<p></p>
延伸讨论：链表呢？有没有其他数据结构能够做到查找-删除操作比 O(n) 更快？
<p></p>
1. 对链表而言，虽然删除操作可以简单通过改变前后指针指向实现 O(1) 的复杂度，但是查找对应元素却需要 O(n) 的时间。
<p></p>
2. 当然有。比如各种平衡树。参考：https://oi-wiki.org/ds/bst/本质上平衡树就是为了减少这一操作的复杂度而利用了树形结构并且引入各种结构调整操作来限制树的深度，以防止出现最坏效率。当然，除了树形结构可以利用分治优化，链式结构也可以，比如跳表:https://oi-wiki.org/ds/skiplist/。

<p></p>
</details>

<p></p>
</details>

4.**若一个栈采用数组$s[0..n-1]$存放其元素，初始时栈顶指针为$n$，则以下元素$x$进栈的操作正确的是**______。  
   A. $\text{top}++;\ s[\text{top}] = x;$  
   B. $s[\text{top}] = x;\ \text{top}++;$  
   C. $\text{top}--;\ s[\text{top}] = x;$  
   D. $s[\text{top}] = x;\ \text{top}--;$  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：C。</b> 其实本题考虑到ABD选项都会造成数组下标越界访问就可以解出。但这个题本意是说从这个数组的尾端向前装数据，也能构成一个栈。这么做可以和一个从前往后装数据的栈组合成一个对顶栈。

<p></p>
</details>


5.**设环形队列中数组的下标为$0\sim N-1$，其队头、队尾指针分别为$\text{front}$和$\text{rear}$（$\text{front}$指向队列中队头元素的前一个位置，$\text{rear}$指向队尾元素的位置），则其元素个数为**______。  
   A. $\text{rear} - \text{front}$  
   B. $\text{rear} - \text{front} - 1$  
   C. $(\text{rear} - \text{front})\%N + 1$  
   D. $(\text{rear} - \text{front} + N)\%N$  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：D。</b> 因为这是一个循环队列，如果 rear 的下标大于 front，那么可以直接相减，但是也可能出现小于的情况，所以需要加上 N 来保证结果是正数，由于可能大于 N，所以要取模。

<p></p>
</details>

6.**若用一个大小为6的数组来实现环形队列，队头指针$\text{front}$指向队列中队头元素的前一个位置，队尾指针$\text{rear}$指向队尾元素的位置。若当前$\text{rear}$和$\text{front}$的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，$\text{rear}$和$\text{front}$的值分别为**______。  
   A. 1和5  
   B. 2和4  
   C. 4和2  
   D. 5和1

<details>

<summary> 答案 </summary>

<p></p>


<b>答案：B。</b> 看图：
<p>
<a href="https://imgse.com/i/pEvSHCd"><img src="https://s21.ax1x.com/2025/05/16/pEvSHCd.png" alt="pEvSHCd.png" border="0" /></a></p>

<p></p>
</details>

7.**一棵高度为$h$（$h\geq1$）的完全二叉树至少有**______个结点。  
   A. $2^{h-1}$  
   B. $2^h$  
   C. $2^h + 1$  
   D. $2^{h-1} + 1$  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：A。</b>首先复习完全二叉树的定义：完全二叉树是除了最后一层以外其他层都满节点的二叉树，且最后一层的节点连续集中在最左边。题目问至少，所以我们让最后一层只有一个节点，那么总的节点数为：

$$
N=1+\sum_{i=0}^{h-2}2^i=2^{h-1}
$$

<p></p>
</details>



8.**设一棵哈夫曼树中有999个结点，该哈夫曼树用于对**______个字符进行编码。  
   A. 999  
   B. 499  
   C. 500  
   D. 501  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：C。</b>首先，哈夫曼树只有叶子节点可以表示数据的编码，因此我们其实就是要求出这个哈夫曼树叶子节点的个数。回忆构建哈夫曼树的过程，一开始有单独的一个叶子节点，然后每添加一个数据就新增一个叶子节点用来表示这个数据，并新增一个非叶子节点。因此叶子节点个数始终比非叶子节点数多 1 。利用这个性质就可算出答案是 500。

<p></p>
</details>


9.**一个含有$n$个顶点的无向连通图采用邻接矩阵存储，则该矩阵一定是**______。  
   A. 对称矩阵  
   B. 非对称矩阵  
   C. 稀疏矩阵  
   D. 稠密矩阵  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：A。</b>对于节点 i 和 j ，邻接矩阵里面的元素 G[i][j] 表示 i 到 j 的路径长度，同理元素 G[j][i] 表示 j 到 i 的路径长度。由于是一个无向图，所以两者应该相等。所以是对称矩阵。至于稀疏还是稠密，就取决于图本身了。

<p></p>
</details>


10.**设无向连通图有$n$个顶点、$e$条边，若满足**______，则图中一定有回路。  
    A. $e\geq n$  
    B. $e < n-1$  
    C. $e = n-1$  
    D. $2e\geq n$  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：A。</b>考虑一开始有 n 个独立的节点，从任意一个节点开始加边，我们尽量不要形成环，那么每一次加边都选择度为 0 的节点，加了 n - 1 次边之后我们发现没有度为 0 的节点了，也就是当 e = n - 1 时，连通图退化成树。此时从节点 i 到节点 j 再加一次边 e_n ，那么 i 到 j 原先的联通路径加上这个新加入的边刚刚好就构成一个环。

<p></p>
</details>


11.**如果从无向图的任一顶点出发进行一次广度优先遍历即可访问所有顶点，则该图一定是**______。  
    A. 完全图  
    B. 连通图  
    C. 有回路  
    D. 一棵树  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：B。</b>连通图是指图中任意两个顶点之间都存在路径相连的无向图。既然能够被搜索到，就意味着肯定有路径相连。完全图、有回路和树的定义更严格。题目中没有更多条件了，只能选到B。

<p></p>
</details>


12.**设有100个元素的有序表，在用折半查找时，不成功查找时最大的比较次数是**______。  
    A. 25  
    B. 50  
    C. 10  
    D. 7  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：D。</b>
折半搜索每次丢弃一半的区间，也就是：
$$
2^6=64\le 100\le 2^7=128
$$
找 6 次可能找不到，但是找 7 次一定找得到。
<p></p>
也可以这样理解：折半查找的时间复杂度是 O(log_2 n) 量级，只有D选项满足这个数量级。
<p></p>
</details>


13.**从100个元素确定的顺序表中查找某个元素（关键字为正整数），如果最多只进行5次元素之间的比较，则采用的查找方法只可能是**______。  
    A. 折半查找  
    B. 顺序查找  
    C. 哈希查找  
    D. 二叉排序树查找  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案 C。</b>

根据上面那个题，O(log_2 n)的算法的比较次数上界是7次，而这个算法比 O(log_2 n) 的比较次数还要少，也就意味着时间复杂度更优，而 AD 的时间复杂度都是 O(log_2 n)，B 是 O(n)，只有 C 的时间复杂度是常数级 O(1)。

<p></p>
</details>


14.**有一个含有$n$（$n>1000$）个元素的数据序列，某人采用了一种排序方法对其按关键字递增排序，该排序方法需要关键字比较，其平均时间复杂度接近最好的情况，空间复杂度为$O(1)$，该排序方法可能是**______。  
    A. 快速排序  
    B. 堆排序  
    C. 二路归并排序  
    D. 基数排序  

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：B。</b>本题其实给了三个限制条件来排除选项：
<p></p>
1. 需要关键字比较：排除基数排序，这个不需要关键字比较。
<p></p>
2. 平均时间复杂度接近最好的情况：排除快速排序，因为它的最坏时间复杂度是 O(n^2)。
<p></p>
3. 空间复杂度 O(1): 排除二路归并排序，因为它的空间复杂度是 O(n log_2 n)。
<p></p>
因此使用的是堆排序，堆排序是基于比较的原地算法，且最好、最坏和平均时间复杂度都是O(n log_2 n)。
<p></p>
</details>


15.**对一个线性序列进行排序，该序列采用单链表存储，最好采用**______方法。  
    A. 直接插入排序  
    B. 希尔排序  
    C. 快速排序  
    D. 都不适合

<details>

<summary> 答案 </summary>

<p></p>

<b>答案：A。</b>D选项拿来凑数的，别选。希尔排序需要进行数据分组，涉及到随机访问，不适合链表结构；快排需要进行多次随机交换，也不适合链表结构。只有插入操作对单链表的复杂度是 O(1) 的。

<p></p>
</details>

### 问答题
1.如果对含有 \( n(n>1) \) 个元素的线性表的运算只有4种：删除第一个元素；删除最后一个元素；在第一个元素前面插入新元素；在最后一个元素的后面插入新元素，则最好采用以下哪种存储结构，并简要说明理由。  
（1）只有尾结点指针没有头结点指针的循环单链表。  
（2）只有尾结点指针没有头结点指针的非循环双链表。  
（3）只有头结点指针没有尾结点指针的循环双链表。  
（4）既有头结点指针也有尾结点指针的循环单链表。  
<details>

<summary> 答案 </summary>
<p>(3)</p>
<p></p>
其实题目想让我们实现的数据结构叫做<b>双端队列</b>。因为插入和删除操作都集中在头尾，我们来分析一下这四个数据结构的时间复杂度：
<p></p>
(1) : 如果这个循环单链表只有尾节点，那么在进行插入和删除最后一个元素的时候，都要去寻找尾节点的前驱节点，但这又是一个单链表，没有前向信息，所以会浪费循环一次即 O(n) 的时间去找前驱。
<p></p>
(2) : 由于这个非循环的双链表没有头节点，在插入和删除第一个元素的时候都要横跨整个链表，也要花 O(n) 的时间。
<p></p>
(3) : 由于这是一个循环双链表，这时候相比于 (1) 和 (2) 而言，插入和删除都能够很方便（也就是 O(1) 时间）获取到头尾附近节点的地址，以进行修改。
<p></p>
(4) : 问题其实和 (1) 一样，即使有头节点也很难去找到尾节点的前驱节点。
<p></p>

我自己用带头尾指针的循环双链表实现了一个简单的双端队列，参考：https://dicaeopolis.github.io/stl-wheels/#deque

<p></p>
</details>

2.对于一个带权连通无向图 \( G \)，可以采用 Prim 算法构造出从某个顶点 \( v \) 出发的最小生成树，问该最小生成树是否一定包含从顶点 \( v \) 到其他所有顶点的最短路径。如果回答是，请予以证明；如果回答不是，请给出反例。 

<details>

<summary> 答案 </summary>

<p></p>
本题考察的是<b>最小（代价）生成树</b>和<b>最短路径树</b>的区别。
<p></p>
我们注意 Prim 算法在加边的时候优先选择<b>长度最短</b>的相邻边，但是 Dijkstra 算法的松弛操作选取的是<b>到源点距离最短</b>的相邻边。这很不一样。
<p></p>
构造反例时可以考虑构造一个树，然后将一个叶子节点和根节点相连，这条新边的权值小于原来根到这个叶子节点的路径长度即可，比如下面这个简单的反例：
<p></p>
<a href="https://imgse.com/i/pEvEBbn"><img src="https://s21.ax1x.com/2025/05/16/pEvEBbn.png" alt="pEvEBbn.png" border="0" /></a>
</details>

3.有一棵二叉排序树按先序遍历得到的序列为 \( (12, 5, 2, 8, 6, 10, 16, 15, 18, 20) \)。回答以下问题：
（1）画出该二叉排序树。  
（2）给出该二叉排序树的中序遍历序列。  
（3）求在等概率下的查找成功和不成功情况下的平均查找长度。  

<details>

<summary> 答案 </summary>

<p></p>

<p></p>
</details>


### 算法设计题  
1.（15分）假设二叉树 \( b \) 采用二叉链存储结构，设计一个算法 `void findparent(BTNode *b, ElemType x, BTNode *&p)` 求指定值为 \( x \) 的结点的双亲结点 \( p \)。提示：根结点的双亲为 `NULL`，若在二叉树 \( b \) 中未找到值为 \( x \) 的结点，\( p \) 也为 `NULL`。 

<details>

<summary> 答案 </summary>

<p></p>
思路是从根节点开始深搜，如果当前节点的子节点值为 x，那么该节点就是所求的节点 p。而且如果已经求得 p，那么剩下的搜索都可以剪枝跳过了。
<p></p>

```cpp
void findparent(BTNode *b, ElemType x, BTNode *&p)
{
   if(b == NULL || b->data == x)// 利用了或运算的短路性质，只有 b != NULL 才会访问 data。
   {
      p = NULL;
      return ;
   }
   if( (b->lchild != NULL && b->lchild->data == x) || (b->rchild != NULL && b->rchild->data == x)) p = b;
   else
   {
      findparent(b->lchild, x, p);
      if(p == NULL)
         findparent(b->rchild, x, p);
   }
}
```

<p></p>
</details>


2.（10分）假设一个有向图 \( G \) 采用邻接表存储，设计一个算法判断顶点 \( i \) 和顶点 \( j \)（\( i \neq j \)）之间是否相互连通，假设这两个顶点均存在。  

<details>

<summary> 答案 </summary>


<p></p>
任意使用一种搜索算法，如果从 i 出发能够搜索到 j，并且从 j 出发能够搜索到 i，那么就说明两者连通。为方便实现我这里使用深度优先搜索。
<p></p>

```cpp
bool vis[N];
std::array<std::vector<int>, N> G;
void dfs(int curr, const int& j, bool& tag)
{
   if(tag) return ;
   if(curr == j)
   {
      tag = true;
      return ;
   }
   vis[curr] = true;
   for(auto adj : G[curr])
      if(!vis[adj])
         dfs(adj, j, tag);
}
bool is_connected(const int& i, const int& j)
{
   std::fill(vis.begin(), vis.end(), 0);
   bool tag_i2j = false, tag_j2i = false;
   dfs(i, j, tag_i2j);
   if(tag_i2j)
   {
      std::fill(vis.begin(), vis.end(), 0);
      dfs(j, i, tag_j2i);
      if(tag_j2i) return true;
   }
   return false;
}
```
<p></p>
</details>


3.（15分）有一个含有 \( n \) 个整数的无序数据序列，所有的数据元素均不相同，采用整数数组 \( R[0..n-1] \) 存储，请完成以下任务：  
（1）设计一个尽可能高效的算法，输出该序列中第 \( k \)（\( 1 \leq k \leq n \)）小的元素，算法中给出适当的注释信息。提示：利用快速排序的思路。  
（2）分析你所设计的求解算法的平均时间复杂度，并给出求解过程。

<details>

<summary> 答案 </summary>

<p></p>
本题可以在洛谷上面做：https://www.luogu.com.cn/problem/P1923
<p></p>

</details>
